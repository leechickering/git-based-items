---
itemId:sw-241
itemType: Software Item Spec
itemTitle: StrykerCore
itemFulfills: 
Software item type: SDD
---
A proprietary library that provides network, persistence, user notification, background downloads, data formatting, and other common utilities for the App.
 
StrykerCore
 
The StykerCore package can set up the dependencies, delegates, and other necessary iOS system configurations for your app so that it can receive notifications properly. To use this feature, make an app delegate class and initiate the `NotificationProxy` object.
 
Note, on visionOS, the app does not support notifications so the notification register and handlers are iOS only.
* Remote Notification and Presentable Notification Handlers`NotificationProxy` provides an array of handlers for both remote (silent push) and presentable notifications. They are `remoteNotificationHandlers` and `presentableNotificationHandlers`, respectively. To add a handler, append the async closure to the handler array at any time during the app's lifecycle. Note that this will only take effect for future notifications that have not yet been received.

 
```swift
class RootViewController: UIViewController {
    override func viewDidLoad() {
        super.viewDidLoad()
        notificationProxy.remoteNotificationHandlers.append({ userInfo in
            let result = await MyDownloader.fetch(URL(string: userInfo["fileURLToDownload"]))
            return result.httpStatus == 200 ? .newData : .failed
        })
    }
}
```
* Each handler will be called asynchronously and is expected to return some value. The values of all the handlers will be evaluated together. This means that (for background notifications) if one background fetch task failed, the other tasks which succeeded are also assumed to have failed as far as the operating system is concerned. If some tasks return `.noData` but others return `.newData` then the operating system is giveen the response of `.newData`.
* To avoid performing expensive tasks over again in a future remote push, you will want to check to see if the work has been performed (eg, look for a downloaded file) and return the appropriate `UIBackgroundFetchResult` for your task.
* Presentable notifications aggregate the `UNNotificationPresentationOptions` reponses in a set. For example, if one handler determines that a sound should be played but another  returns just `.banner`, the operating system will be told to present the notification with both a sound and a banner. For a notification to be completely surpressed, _all_ handlers must return `[]` as their `UNNotificationPresentationOptions` value.
* The app delegate which stores developer environment api keys and other connection information in a convenience struct that conforms to the `AppAPIConfig` protocol, which is provided by the package.
 
The app delegate handles registering with APNS, registering with Health Cloud, and the `UNNotificationCenter` delegate methods.
 
```swift
import StrykerCore
 
class AppDelegate    
 
    func getNotificationProxy() -> NotificationProxy {
        @Dependency(\.auth0AppEngine) var auth0AppEngine
 
        // The healthCloudNotifications client will listen for an auth token before completing the notification registration process.
        // Until the user has logged in at least once, no notifications can be received.
        let healthCloudClient = HealthCloudNotificationClient(apiKey: "",
                                                              apiKeyHeaderName: "",
                                                              endpointBaseUrl: auth0AppEngine.apiEnvironment().baseUrl.appending(path: "mako/case-api/1.0/notifications"),
                                                              getAccessToken: { try await auth0AppEngine.authClient().getAccessToken() })
 
        return NotificationProxy(client: healthCloudClient)
 
    }
``` 
* Security
	* The `SecurityService` handles security related tasks and signals. The purpose of this feature is to protect the app according to the OWASP MASVS standard.
	* Currently this service has the following capabilities: 
		* If a device is jailbroken device
		* Common reverse engineering tools running on the device
	* There is a check in the jailbreak detection module (within the IOSSecuritySuite SDK) that uses [`canOpenURL(_:)](https://developer.apple.com/documentation/uikit/uiapplication/1622952-canopenurl) method and requires specifying the URL's that can be queried. If the consumer wants to utilize the device check capabilities they will need to update their `.plist` file with the code snippet below: 
 
```xml
<key>LSApplicationQueriesSchemes</key>
<array>
<string>undecimus</string>
<string>sileo</string>
<string>zbra</string>
<string>filza</string>
<string>activator</string>
</array>
```